import os
import json
import ipdb
# This script is to read the json files generated by endpoint.py and count statistics.
# And to convert the rdf forms into textual form and save in a file textualized.json under the same directory.
from tqdm import tqdm
import random
from string import Template
from SPARQLWrapper import SPARQLWrapper, JSON
import time

# this function is used to calculate how many triples in specific file
def get_stat():
    for filename in os.listdir(os.getcwd()):
        if filename.endswith('.json') and filename in ['4e_v2_noAsso.json']:
            with open(os.path.join(os.getcwd(), filename), 'r') as f: 
                triples = json.load(f)
                print(triples[0], filename)
                con = dict()
                num = 0
                for i in triples:
                    for value in i.values():
                        if value["value"] in con:
                            con[value["value"]] += 1
                        if value["value"] not in con:
                            con[value["value"]] = 0
                ipdb.set_trace()
                print(f'This file {filename} has {num} which contains type in their triple, with totaly {len(triples)} graphs matched.')
    return

def get_answer(query):
    out = list()
    endpoint = "http://sems-coypu-4.informatik.uni-hamburg.de:8890/sparql/"
    sparql = SPARQLWrapper(endpoint)
    sparql.setReturnFormat(JSON)
    
    sparql.setQuery(
       query
    )

    try:
        ret = sparql.queryAndConvert()

        for r in ret["results"]["bindings"]:
            print(r)
            out.append(r)
#        return ret["results"]["bindings"]
    except Exception as e:
        print(e)
    time.sleep(2) 
    return out
# main function to: 1. get the triple files in the same directory; 
# 2. convert the triples to text form
# 3. save in a json file
def convert(entDict:dict):
    '''
    entDict: dictionary from getEntDIct function
    return the number of triple processed and a line of info
    '''
    out = []
    for filename in os.listdir(os.getcwd()):
        if filename.endswith('.json'):
            with open(os.path.join(os.getcwd(), filename), 'r') as f:   
                triples = json.load(f)
                for triple in tqdm(triples):
                    # extract the triplea based on the subgraph-pattern
                    if filename.startswith("0"):
                        text_triple = {"type":filename.split("json")[0]}
                        subgraphs = [(triple["subj"], triple["prop"]["value"], triple["obj"])]
                        answer = random.choice([subgraphs[0][0], subgraphs[0][1], subgraphs[1][2]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop  $obj.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop=subgraphs[0][1], obj=subgraphs[0][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj"], entDict), triple["prop"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict))]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = end_answer
                        text_triple["sparql"] = sparql


                    if filename.startswith("1_v2.json"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(triple["subj"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["subj"], triple["prop2"]["value"], triple["obj2"])]
                        answer = random.choice([subgraphs[0][2], subgraphs[0][1], subgraphs[1][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop1  $obj1.
                                $sub  $prop2  $obj2.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["subj"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict))]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql

                    if filename.startswith("2"):
                        text_triple = {"type":filename.split("json")[0]}
                        subgraphs = [(triple["subj"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["obj1"], triple["prop2"]["value"], triple["obj2"])]
                        answer = random.choice([subgraphs[0][2], subgraphs[0][1], subgraphs[1][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop1  $obj1.
                                $obj1  $prop2  $obj2.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["obj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict))]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql
        
                    if filename.startswith("3"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(triple["subj"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["subj"], triple["prop2"]["value"], triple["obj2"]),
                                  (triple["obj1"], triple["prop3"]["value"], triple["subj"])]
                        answer = random.choice([subgraphs[0][0], subgraphs[0][1], subgraphs[1][1], subgraphs[2][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop1  $obj1.
                                $sub  $prop2  $obj2.
                                $obj1  $prop3  $sub.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], prop3=subgraphs[2][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["subj"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)),
                                    (Eid2label(triple["obj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj"], entDict))]       
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql                       

                    if filename.startswith("4"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(triple["subj1"], triple["prop1"]["value"], triple["obj"]), 
                                    (triple["subj2"], triple["prop2"]["value"], triple["obj"])]                                  
                        answer = random.choice([subgraphs[0][2], subgraphs[0][1], subgraphs[1][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub1  $prop1  $obj.
                                $sub2  $prop2  $obj.
                                }}
                                """)
                        sparql.substitute(sub1=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], obj1=subgraphs[0][2], sub2=subgraphs[1][0]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                    (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict))]    
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql

                    if filename.startswith("5"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict))],
                                        "answer": sample([Eid2label(triple["subj1"], entDict), 
                                                          Eid2label(triple["subj2"], entDict),
                                                          Eid2label(triple["obj"], entDict),
                                                          triple["prop1"]["value"].split('/vocab/')[-1], 
                                                          triple["prop2"]["value"].split('/vocab/')[-1],
                                                          triple["prop3"]["value"].split('/vocab/')[-1]
                                                          ], 1)
                                                    }

                    if filename.startswith("6"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["subj1"], entDict))]
                                                    }
                    if filename.startswith("7"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraph = [(triple["subj"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["obj1"], triple["prop2"]["value"], triple["obj2"]), 
                                    (triple["obj1"], triple["prop3"]["value"], triple["subj"])]
                        
                        answer = random.choice([subgraph[0][2], subgraph[0][1], subgraph[1][1], subgraph[2][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop1  $obj1.
                                $obj1  $prop2  $obj2.
                                $obj1  $prop3  $sub.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], prop3=subgraphs[2][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraph = [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["obj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)), 
                                    (Eid2label(triple["obj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj"], entDict))]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraph
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql

                    if filename.startswith("8"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(triple["subj"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["obj1"], triple["prop2"]["value"], triple["obj2"]), 
                                    (triple["obj1"], triple["prop3"]["value"], triple["subj"]), 
                                    (triple["obj2"], triple["prop4"]["value"], triple["obj1"])]
                        answer = random.choice([subgraphs[0][2], subgraphs[0][1], subgraphs[1][1], subgraphs[2][1]], subgraphs[3][1])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub  $prop1  $obj1.
                                $obj1  $prop2  $obj2.
                                $obj1  $prop3  $sub.
                                $obj2  $prop4  $obj1.
                                }}
                                """)
                        sparql.substitute(sub=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], prop3=subgraphs[2][1], prop4=subgraphs[3][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)
                        subgraphs = [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                                  (Eid2label(triple["obj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)), 
                                                  (Eid2label(triple["obj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj"], entDict)), 
                                                  (Eid2label(triple["obj2"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict))]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql

                    if filename.startswith("9"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                                  (Eid2label(triple["obj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)), 
                                                  (Eid2label(triple["obj2"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj"], entDict))]
                                                    }
                    if filename.startswith("10"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["subj1"], entDict))]
                                                    }
                    if filename.startswith("11"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict))]
                                                    }
                    if filename.startswith("12"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop5"]["value"].split('/vocab/')[-1], Eid2label(triple["subj1"], entDict))]
                                                    }
                    if filename.startswith("13"):
                        continue
                        text_triple = { "type":filename.split("json")[0],
                                        "value": [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj"], entDict)), 
                                                  (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop4"]["value"].split('/vocab/')[-1], Eid2label(triple["subj2"], entDict)), 
                                                  (Eid2label(triple["obj"], entDict), triple["prop5"]["value"].split('/vocab/')[-1], Eid2label(triple["subj1"], entDict)), 
                                                  (Eid2label(triple["subj2"], entDict), triple["prop6"]["value"].split('/vocab/')[-1], Eid2label(triple["subj1"], entDict))]
                                                    }
                    if filename.startswith("4e"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["obj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)), 
                                    (Eid2label(triple["obj2"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["obj3"], entDict))]
                        answer = random.choice(subgraphs[0].union(subgraphs[1]).union(subgraphs[2]))
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub1  $prop1  $obj1.
                                $obj1  $prop2  $obj2.
                                $obj2  $prop3  $obj3.
                                }}
                                """)
                        sparql.substitute(sub1=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], prop3=subgraphs[2][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2], obj3=subgraphs[2][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)  
                        subgraphs = [(triple["subj1"], triple["prop1"]["value"], triple["obj1"]), 
                                                  (triple["obj1"], triple["prop2"]["value"], triple["obj2"]), 
                                                  (triple["obj2"], triple["prop3"]["value"], triple["obj3"])]
                        if "node" in end_answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                            
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql

                    if filename.startswith("4f"):
                        text_triple = { "type":filename.split("json")[0]}
                        subgraphs = [(triple["subj1"], triple["prop1"]["value"], triple["obj1"]), 
                                    (triple["subj1"], triple["prop2"]["value"], triple["obj2"]), 
                                    (triple["subj1"], triple["prop3"]["value"], triple["obj3"])]
                        answer = random.choice([subgraphs[0][0], subgraphs[0][1], subgraphs[1][1], subgraphs[2][1]])
                        sparql = Template("""
                                SELECT DISTINCT ?uri
                                WHERE {{
                                $sub1  $prop1  $obj1.
                                $sub1  $prop2  $obj2.
                                $sub1  $prop3  $obj3.
                                }}
                                """)
                        sparql.substitute(sub1=subgraphs[0][0], prop1=subgraphs[0][1],  prop2=subgraphs[1][1], prop3=subgraphs[2][1], obj1=subgraphs[0][2], obj2=subgraphs[1][2], obj3=subgraphs[2][2]).replace(answer, "?uri")
                        end_answer = get_answer(sparql)  
                        subgraphs = [(Eid2label(triple["subj1"], entDict), triple["prop1"]["value"].split('/vocab/')[-1], Eid2label(triple["obj1"], entDict)), 
                                    (Eid2label(triple["subj1"], entDict), triple["prop2"]["value"].split('/vocab/')[-1], Eid2label(triple["obj2"], entDict)), 
                                    (Eid2label(triple["subj1"], entDict), triple["prop3"]["value"].split('/vocab/')[-1], Eid2label(triple["subj3"], entDict))]
                        if "node" in answer:
                            answer = Eid2label(end_answer, entDict)
                        else:
                            answer = end_answer.split('/vocab/')[-1]
                        text_triple["value"] = subgraphs
                        text_triple["answer"] = answer
                        text_triple["sparql"] = sparql


                    # filter out the triples with null values, resulted from long id which are falsely created
                    for text_graph in text_triple["value"]:
                        if None in text_graph:
                            text_triple = None
                            break
                    if text_triple:
                        out.append(text_triple)



    with open("total/with_sparql.json", 'w') as f:
        json.dump(out, f, indent=4)

    f.close()
    print(f"{len(out)} textualized triples have beem created")
    return


# helper function to convert the long EID to text form
def Eid2label(triple:dict, entDict:dict):
    '''
    id: triple saved in the json file from endpoint output
    labe: textual label
    '''
    id = triple["value"].split("node/")[-1]
    if len(id) <= 10:
        return entDict[id]
    return None


# load the entity ID2Label dictionary 
def getEntDIct(filename:str) -> dict:
    '''
    filename: the address of the dictionary generated by reading kg.csv file
    '''
    with open(filename) as f:
        entDict = json.load(f)[0]
    f.close()
    return entDict

# check the duplicate relation percentage in different files
def compare():
    num_1 = {}
    num_2 = {}

    for filename in os.listdir(os.getcwd()):
        if filename =="12_v2.json":
            with open(os.path.join(os.getcwd(), filename), 'r') as f: 
                triples = json.load(f)
                for triple in triples:
                    if triple["prop1"] == triple["prop5"]:
                        if triple["prop1"]["value"] in num_1:
                            num_1[triple["prop1"]["value"]] += 1
                        else:
                           num_1[triple["prop1"]["value"]] = 0
                    if triple["prop2"] == triple["prop4"]:
                        if triple["prop2"]["value"] in num_2:
                            num_2[triple["prop2"]["value"]] += 1
                        else:
                           num_2[triple["prop2"]["value"]] = 0
    print(num_1, num_2)
    return                
if __name__ == "__main__":
    # convert ids to labels
    entDict = getEntDIct("/storage/yan/primekg/kg/ent_dict.json")
    convert(entDict)
#    get_stat()
#    compare()